### 函数泛型

我写了两个函数一个是数字类型的函数，另一个是字符串类型的函数,其实就是类型不同，

实现的功能是一样的，这时候我们就可以使用泛型来优化

```ts
function num(a: number, b: number): Array<number> {
  return [a, b];
}
num(1, 2);
function str(a: string, b: string): Array<string> {
  return [a, b];
}
str("独孤", "求败");
```

1. 泛型优化

语法为函数名字后面跟一个<参数名> 参数名可以随便写 例如我这儿写了 T

当我们使用这个函数的时候把参数的类型传进去就可以了 （也就是动态类型）

```ts
function Add<T>(a: T, b: T): Array<T> {
  return [a, b];
}

// Add<number>(1, 2);
Add(1, 2); //自动推断
Add<string>("1", "2");
```

2. 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。

```ts
function Sub<T, U>(a: T, b: U): Array<T | U> {
  const params: Array<T | U> = [a, b];
  return params;
}

Sub<Boolean, number>(false, 1);
```

### 定义泛型接口和类型

声明接口的时候 在名字后面加一个<参数>

使用的时候传递类型

```ts
interface MyInter<T> {
  (arg: T): T;
}

function fn<T>(arg: T): T {
  return arg;
}

let result: MyInter<number> = fn;

result(123);

type A<T> = string | number | T;

let a: A<boolean> = true;
```

### 对象字面量泛型

```ts
let foo: { <T>(arg: T): T };

foo = function <T>(arg: T): T {
  return arg;
};

foo(123);
```

### 泛型的默认值

```ts
interface MyInter<T = string> {
  name: T;
}
```

### 封装 axios

```ts
const axios = {
  get<T>(url: string): Promise<T> {
    return new Promise((resolve, reject) => {
      const xhr: XMLHttpRequest = new XMLHttpRequest();
      xhr.open("GET", url);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            resolve(JSON.parse(xhr.responseText));
          } else {
            reject(xhr.status);
          }
        }
      };
      // 发送请求
      xhr.send(null);
    });
  },
};

interface Data {
  code: number;
  message: string;
}

axios.get<Data>("./data.json").then((res) => {
  console.log(res);
});
```
